# Deployment and Docker operations for Benchling Integration
# This file contains production deployment targets, Docker image building, and ECR push operations

# Docker base image name for ECR (without architecture suffix)
DOCKER_IMAGE_BASE := quiltdata/benchling

# Version is read from pyproject.toml by docker.py
# Can be overridden with VERSION=x.y.z
VERSION ?=

# Detect architecture and set appropriate image name
ARCH := $(shell uname -m | tr '[:upper:]' '[:lower:]')
ifeq ($(ARCH),x86_64)
	ARCH := amd64
endif
ifeq ($(ARCH),aarch64)
	ARCH := arm64
endif

# Export appropriate image name based on target
export DOCKER_IMAGE_NAME ?= $(DOCKER_IMAGE_BASE)

# AWS region for ECR
AWS_REGION ?= us-east-1

.PHONY: deploy-help docker-build-local push-local push-ci \
        docker-tools docker-ecr-login docker-validate deploy-clean \
        docker-ecr-create

# ==============================================================================
# Help
# ==============================================================================

deploy-help:
	@echo "Benchling Integration - Deployment & Docker Commands"
	@echo ""
	@echo "Docker Build & Push (Simplified):"
	@echo "  push-local            - Build and push with arch in image name"
	@echo "                          ‚Üí quiltdata/benchling-arm64:v1.0.0, :latest"
	@echo "                          Use for local development and testing"
	@echo "                          (Auto-creates both arch-specific and generic ECR repos)"
	@echo "  push-ci               - Build and push with generic image name"
	@echo "                          ‚Üí quiltdata/benchling:v1.0.0, :latest"
	@echo "                          Use in CI/CD pipeline on benchling-docker branch"
	@echo "                          (Requires ECR repos to exist - run push-local first)"
	@echo "  docker-build-local    - Build Docker image locally without pushing"
	@echo ""
	@echo "  Add DRY_RUN=1 to any push command for dry run mode:"
	@echo "    make push-local DRY_RUN=1"
	@echo "    make push-ci DRY_RUN=1"
	@echo ""
	@echo "Docker Tools & Setup:"
	@echo "  docker-tools          - Verify Docker is installed and running"
	@echo "  docker-ecr-create     - Create ECR repos with public read access"
	@echo "                          (Creates both arch-specific and generic repos)"
	@echo "  docker-ecr-login      - Login to ECR registry"
	@echo "  docker-validate       - Validate pushed Docker images in registry"
	@echo ""
	@echo "Maintenance:"
	@echo "  deploy-clean          - Clean deployment artifacts"
	@echo ""
	@echo "Workflow:"
	@echo "  Local:  make push-local  ‚Üí quiltdata/benchling-$(ARCH):v1.0.0"
	@echo "  CI:     make push-ci     ‚Üí quiltdata/benchling:v1.0.0"
	@echo ""
	@echo "Environment Variables:"
	@echo "  VERSION               - Docker image version (default: git describe)"
	@echo "  AWS_REGION            - AWS region for ECR (default: us-east-1)"
	@echo "  DOCKER_IMAGE_BASE     - Base Docker image name (default: quiltdata/benchling)"

# ==============================================================================
# Docker Tools & Prerequisites
# ==============================================================================

docker-tools:
	@command -v docker >/dev/null 2>&1 || { echo "‚ùå Docker not found - install Docker"; exit 1; }
	@docker info >/dev/null 2>&1 || { echo "‚ùå Docker daemon not running or not accessible"; exit 1; }
	@command -v uv >/dev/null 2>&1 || { echo "‚ùå uv not found - install uv package manager"; exit 1; }
	@echo "‚úÖ Docker tools available"

docker-ecr-login: docker-tools
	@echo "üîê Logging in to ECR..."
	@AWS_ACCOUNT_ID=$$(aws sts get-caller-identity --query Account --output text 2>/dev/null) || \
		{ echo "‚ùå Failed to get AWS account ID - check AWS credentials"; exit 1; }; \
	aws ecr get-login-password --region $(AWS_REGION) | \
		docker login --username AWS --password-stdin $$AWS_ACCOUNT_ID.dkr.ecr.$(AWS_REGION).amazonaws.com
	@echo "‚úÖ ECR login successful"

# Create ECR repositories with public read access
# Creates both architecture-specific (e.g., quiltdata/benchling-arm64) and generic (quiltdata/benchling) repos
# Applies public read policy to allow unauthenticated pulls (required for CI)
docker-ecr-create: docker-tools
	@echo "üì¶ Creating ECR repositories with public read access..."
	@AWS_ACCOUNT_ID=$$(aws sts get-caller-identity --query Account --output text 2>/dev/null) || \
		{ echo "‚ùå Failed to get AWS account ID - check AWS credentials"; exit 1; }; \
	echo "Account: $$AWS_ACCOUNT_ID"; \
	echo "Region: $(AWS_REGION)"; \
	echo ""; \
	ARCH_REPO=$(DOCKER_IMAGE_BASE)-$(ARCH); \
	GENERIC_REPO=$(DOCKER_IMAGE_BASE); \
	for REPO in $$ARCH_REPO $$GENERIC_REPO; do \
		echo "Processing repository: $$REPO"; \
		if aws ecr describe-repositories --repository-names $$REPO --region $(AWS_REGION) >/dev/null 2>&1; then \
			echo "  ‚úÖ Repository already exists: $$REPO"; \
		else \
			aws ecr create-repository --repository-name $$REPO --region $(AWS_REGION) >/dev/null; \
			echo "  ‚úÖ Successfully created repository: $$REPO"; \
		fi; \
		echo "  üîì Setting public read policy..."; \
		POLICY_FILE="/tmp/ecr-policy-$$(echo $$REPO | tr '/' '-').json"; \
		echo '{"Version":"2012-10-17","Statement":[{"Sid":"PublicReadAccess","Effect":"Allow","Principal":"*","Action":["ecr:GetDownloadUrlForLayer","ecr:BatchGetImage","ecr:BatchCheckLayerAvailability"]}]}' > $$POLICY_FILE; \
		aws ecr set-repository-policy \
			--repository-name $$REPO \
			--policy-text file://$$POLICY_FILE \
			--region $(AWS_REGION) >/dev/null 2>&1 && \
			echo "  ‚úÖ Public read policy applied to $$REPO" || \
			echo "  ‚ö†Ô∏è  Failed to apply public read policy to $$REPO"; \
		rm -f $$POLICY_FILE; \
		echo ""; \
	done; \
	echo "‚úÖ ECR repository setup complete"

# ==============================================================================
# Docker Build Operations
# ==============================================================================

docker-build-local: docker-tools
	@echo "üê≥ Building Docker image locally..."
	@echo "Version: $(VERSION)"
	@echo "Architecture: $(shell uname -m)"
	uv run python scripts/docker.py build --version $(VERSION)

# ==============================================================================
# Docker Push Operations (Simplified)
# ==============================================================================

# Push from local machine with architecture in image name (e.g., quiltdata/benchling-arm64:v1.0.0)
# Use this for local development and testing
# Set DRY_RUN=1 for dry run mode
push-local: check-env docker-tools docker-ecr-create
	@if [ "$(DRY_RUN)" = "1" ]; then \
		echo "üîç DRY RUN: Would push architecture-specific Docker image (local)..."; \
	else \
		echo "üê≥ Building and pushing architecture-specific Docker image (local)..."; \
		$(MAKE) -f make.deploy docker-ecr-login; \
	fi
	@echo "Image: $(DOCKER_IMAGE_BASE)-$(ARCH)"
	@echo "Architecture: $(ARCH)"
	@echo ""
	@if [ "$(DRY_RUN)" = "1" ]; then \
		DOCKER_IMAGE_NAME=$(DOCKER_IMAGE_BASE)-$(ARCH) uv run python scripts/docker.py push $(if $(VERSION),--version $(VERSION)) --no-arch-suffix --dry-run; \
	else \
		DOCKER_IMAGE_NAME=$(DOCKER_IMAGE_BASE)-$(ARCH) uv run python scripts/docker.py push $(if $(VERSION),--version $(VERSION)) --no-arch-suffix; \
	fi

# Push from CI with generic image name (e.g., quiltdata/benchling:v1.0.0)
# Use this in CI/CD on merge to benchling-docker branch
# Set DRY_RUN=1 for dry run mode
# Note: Does NOT auto-create ECR repos (assumes they exist from previous push-local)
# Note: Does NOT require check-env since CI provides credentials via OIDC
push-ci: docker-tools
	@if [ "$(DRY_RUN)" = "1" ]; then \
		echo "üîç DRY RUN: Would push unified Docker image (CI)..."; \
	else \
		echo "üê≥ Building and pushing unified Docker image (CI)..."; \
		$(MAKE) -f make.deploy docker-ecr-login; \
	fi
	@echo "Image: $(DOCKER_IMAGE_BASE)"
	@echo "Architecture: $(ARCH)"
	@echo ""
	@if [ "$(DRY_RUN)" = "1" ]; then \
		DOCKER_IMAGE_NAME=$(DOCKER_IMAGE_BASE) uv run python scripts/docker.py push $(if $(VERSION),--version $(VERSION)) --no-arch-suffix --dry-run; \
	else \
		DOCKER_IMAGE_NAME=$(DOCKER_IMAGE_BASE) uv run python scripts/docker.py push $(if $(VERSION),--version $(VERSION)) --no-arch-suffix; \
	fi

# ==============================================================================
# Docker Validation
# ==============================================================================

docker-validate: docker-tools
	@echo "üîç Validating Docker images in public registry (WITHOUT login)..."
	@if [ ! -f ../cdk-outputs.json ]; then \
		echo "‚ùå Error: cdk-outputs.json not found"; \
		echo "Run CDK deploy first to generate outputs"; \
		exit 1; \
	fi
	@DOCKER_IMAGE_URI=$$(cat ../cdk-outputs.json | grep -o '"DockerImageUri"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"DockerImageUri"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/'); \
	if [ -z "$$DOCKER_IMAGE_URI" ]; then \
		echo "‚ùå Error: DockerImageUri not found in cdk-outputs.json"; \
		exit 1; \
	fi; \
	echo "Image URI: $$DOCKER_IMAGE_URI"; \
	echo "‚ö†Ô∏è  This validation will FAIL if the repository is not public"; \
	echo "Attempting to pull image WITHOUT authentication..."; \
	if docker pull "$$DOCKER_IMAGE_URI" 2>&1 | tee /dev/stderr | grep -q "unauthorized\|authentication required\|no basic auth credentials"; then \
		echo "‚ùå VALIDATION FAILED: Repository is NOT public (requires authentication)"; \
		exit 1; \
	else \
		echo "‚úÖ VALIDATION PASSED: Repository is publicly accessible"; \
	fi

# ==============================================================================
# Cleanup
# ==============================================================================

deploy-clean:
	@echo "üßπ Cleaning deployment artifacts..."
	@docker system prune -f
	@echo "‚úÖ Deployment cleanup completed"
